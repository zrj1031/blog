# 浅谈monorepo

> 现在业内对`repo`的组织方式开始从`multiple repo`转而推崇`monorepo`, 那它有什么好处, 毕竟新东西意味着新的学习成本, 它一定是解决了我们开发上的某些痛点,
 另外本篇幅不涉及具体的monorepo技术细节选型，如`rush`、`lerna`

## 更统一的业务视角，项目没有割裂

我在猪厂做的是一款客服产品, 根据不同的功能模块会分成在线端、呼叫端、智能端, 但有时候会导致对应的rd同学只关心自己负责的每个项目，无法以整体的业务视角看待

有些业务可能有bff模块, 拆成多个repo总觉得割裂

一个需求如果涉及多个`repo`时，`multi repo`的`git`也显得不统一，a仓库有改动，b仓库有改动，`merge branch`和`code review`时都有一种割裂感, 明明做的是同一件事，却涉及那么多仓库

## 复用一些CI、CD

一些构建发布的流水线、`eslint`、`prettier`等相关配置可以收敛至一份

## 公共业务模块不再依赖npm包

有一些公共业务模块(`components`、`hooks`)的复用, 如果一直使用复制粘贴大法, 同样一份代码多处存在是我们极力要避免的, 且后续的更新迭代都需要手工再复制粘贴（也可能a项目迭代了一些功能，b项目迭代了另外的功能，慢慢的就变成不是一个东西了）

我们可能会把这些公共组件抽成私有npm包, 但是用npm包的模式也会遇到一些问题

`a`项目、`b`项目依赖了`foo`包, 随着时间更迭`a`项目依赖`foo@3.x`, `b`项目还在`foo@1.x`，这时候想在`foo`上加个新功能给`b`使用，`foo`从`v1-v2-v3`的破坏性更新让`foo`的升级又心惊胆战

针对上述的问题，最好的办法还是强制保持各个项目（`a`、`b`）都依赖最新的`foo`, 每次对`foo`升级后, 观察各个项目是否符合预期

但如果多仓库，不太能知道到底有多少项目依赖了`foo`
且每次调整, 都需要对`foo`发布一次`npm`，对`a`、`b`更新`foo`的版本号，再发布项目`a、b`, 流程感觉较为繁琐,
本地调试时也是（需要通过软链设置）

但是在一个`monorepo`下我们就可以快速的搜一下, 知道哪些项目会受影响（可以做到心中有底）, 对于锁定最新版本，在一些`monorepo`的生态中我们可以直接写死`foo: workspace:*`

## 节省node_modules空间

monorepo模式下, 可以减少共同依赖的重复安装, 当然pnpm也可以做到这一点, 安利pnpm一波, 详情可见pnpm的[topic](https://zrj1031.github.io/pnpm.html#npm-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98)
